package fr.ima.bigdata;

import org.apache.commons.lang3.StringUtils;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;

import scala.Tuple2;

public class SparkTP1 {

	private static final String INPUT_DIR = "input.dir";
	private static final String OUTPUT_DIR = "output.dir";
	
	// Classe d'âge de l'assuré
	private static final int ID_AGE_BEN_SNDS = 2;
	// Nature de la prestation
	private static final int ID_PRS_NAT = 39;
	// Montant de la prestation
	private static final int ID_PRS_PAI_MNT = 20;
	// Variable : age de l'assuré
	private static final String VAR_AGE_ASSURE = "AGE_BEN_SNDS";	
	
	public static void main(String[] args) {
		
		//Création d'une appli Spark qui s'exécute sur le noeud local
		SparkConf conf = new SparkConf().setAppName("TP Spark");
		JavaSparkContext sc = new JavaSparkContext(conf);
		
		//Création du RDD : lecture du fichier
		JavaRDD<String> lines = sc.textFile(System.getProperty(INPUT_DIR)!=null? System.getProperty(INPUT_DIR):args[0]).filter(x->!x.contains("AGE_BEN_SNDS")); //Suppression de la ligne d'entête
		
		//Regroupement des classes
		JavaPairRDD<String, Float> prestations = lines.mapToPair(
				new PairFunction<String,String,Float>(){
					
					@Override
					public Tuple2<String, Float> call(String line) throws Exception{
						
						Tuple2<String,Float> ret = null;
						String age = null;
						String naturePrestation = null;
						Float montant = null;
						//On ignore l'entête : si une ligne contient "AGE_BEN_SNDS" c'est qu'il s'agit de l'entête
						if (!line.contains(VAR_AGE_ASSURE)) {
							String[] values = line.split(",");
							//On regroupe les montants remboursés pour chaque nature de prestation et classe d'âge
							age = values[ID_AGE_BEN_SNDS];
							naturePrestation = values[ID_PRS_NAT];
							montant = StringUtils.isNotEmpty(values[ID_PRS_PAI_MNT])?Float.parseFloat(values[ID_PRS_PAI_MNT]) : 0;
							
							ret = new Tuple2<String, Float>(age+"_"+naturePrestation,montant);
						}
						
						return ret;
					}
				}
	);
		
	//
	// MOYENNE
	//
		
	//Pour chaque valeur, je retourne en plus de la valeur, un compteur égal à 1 qui sera additionné ensuite pour
	//calculer le nombre d'éléments par catégorie
	JavaPairRDD<String, Float> resultsMeanRDD = prestations.mapValues(
			
			new Function<Float, Tuple2<Float, Integer>>(){
				
				public Tuple2<Float,Integer> call(Float t) throws Exception{
					return new Tuple2<Float,Integer>(t,1);
				}
			})
	// Pour chaque catégorie, la fonction reduce permet d'effecteur l'addition des valeurs et des compteurs
	.reduceByKey(
			new Function2<Tuple2<Float, Integer>, Tuple2<Float, Integer>, Tuple2<Float, Integer>>(){
				
				public Tuple2<Float,Integer> call(Tuple2<Float,Integer> v1,Tuple2<Float,Integer> v2) throws Exception {
					return new Tuple2<Float,Integer>(v1._1()+v2._1(), v1._2()+v2._2());
				}
			})
	// Pour chaque catégorie réduite par le calcul précédent, je divise le montant par le nombre pour déterminer le montant moyen
	.mapValues(
			new Function<Tuple2<Float,Integer>,Float>(){
				
				public Float call(Tuple2<Float,Integer> v1) throws Exception {
					return v1._1()/v1._2();
				}
			}
		);
	}
			
}